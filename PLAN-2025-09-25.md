# Implementation Plan (September 25, 2025)

This plan breaks down the architecture refactor into granular, trackable tasks. After each numbered step, the assignee must:

- ensure the project builds cleanly without warnings,
- run all relevant automated tests (including any newly added or modified tests) and verify they pass,
- review the diff for unintended changes,
- create a descriptive git commit,
- push the branch to the origin remote to preserve the incremental history.

If any step cannot be completed as written, document the variance in this file before proceeding.

## ✅ 1. Introduce Application Composition Layer (Completed September 25, 2025)
1.1 ✅ Created the `UnifiedScanner/AppEnvironment` module defining protocols for shared services.
1.2 ✅ Implemented adapters wrapping the existing singleton-backed services.
1.3 ✅ Updated `UnifiedScannerApp` to build and inject an `AppEnvironment` via `environmentObject`.
1.4 ✅ Adjusted unit tests to inject dependencies through the new environment where needed.
1.5 ✅ Verified clean build/tests, committed, and pushed to `main`.

## ✅ 2. Decompose SnapshotService (Completed September 25, 2025)
2.1 ✅ Created `DevicePersistenceCoordinator` to handle load/save operations and detect snapshot differences.
2.2 ✅ Introduced `DeviceClassificationCoordinator` plus an injectable `SnapshotClock` to manage classification triggers and timing.
2.3 ✅ Added a `DeviceMutationPublishing` protocol with a `DeviceMutationBusPublisher` adapter so `SnapshotService` no longer depends on the global singleton directly.
2.4 ✅ Refactored `SnapshotService` to consume the new collaborators while preserving actor isolation and existing behaviors.
2.5 ✅ Updated related tests to inject the new publisher/coordinators and rely on the refactored service.
2.6 ✅ Verified clean builds/tests, committed, and pushed on `main`.

## ✅ 3. Replace Global Singletons With Injected Dependencies (Completed September 25, 2025)
3.1 ✅ Updated services (notably `HTTPFingerprintService`) to drop static hooks and rely on injected dependencies.
3.2 ✅ Adjusted `AppEnvironment` and `UnifiedScannerApp` to configure lookup providers and supply concrete implementations explicitly.
3.3 ✅ Audited remaining global references, introducing adapters for mutation publishing and OUI lookup injection.
3.4 ✅ Updated relevant tests to consume the injected publishers/services.
3.5 ✅ Verified builds/tests, committed, and pushed to `main`.

## 4. Modularize Classification and Display Name Rules
4.1 Split `ClassificationService` into rule groups (fingerprint, hostname, service, port, fallback) represented as individual strategy types or data tables.
4.2 Create a registry or pipeline builder that assembles rule sets based on injected configuration, enabling simpler extension.
4.3 Extract Apple-specific display name and classification logic into dedicated modules that consume data from `AppleModelDatabase` (consider loading configuration from JSON/CSV instead of hard-coded arrays).
4.4 Ensure unit tests cover each strategy independently; add regression tests for previously brittle heuristics.
4.5 Run tests, commit, and push.

## 5. Consolidate UI Status Components and Interaction Logic
5.1 Refactor duplicated status/progress UI (currently in `ContentView`, `StatusSectionView`) into reusable components backed by view models sourced from the new environment.
5.2 Move interaction logic (open URL, copy to clipboard, run actions) out of `UnifiedDeviceDetail` into a testable view model, updating views to bind to published state/actions.
5.3 Update SwiftUI previews and existing UI tests (add new ones if missing) to reflect environment injection.
5.4 Run tests, commit, and push.

## 6. Final Integration Pass
6.1 Perform a holistic audit ensuring all modules use injected dependencies, no residual singletons remain in production code paths, and documentation reflects the new architecture.
6.2 Update README/PROJECT_OVERVIEW with a high-level summary of the new architecture and dependency injection approach.
6.3 Run the full test suite, perform a final code review, commit, and push.

---

**Testing & Version Control Expectations**
- At every step above, execute relevant test targets (`UnifiedScannerTests`, UI tests where applicable) and add or update tests alongside code changes.
- Every successful step must end with a git commit and a push to origin, using descriptive messages (e.g. "Refactor SnapshotService to use DevicePersistenceCoordinator").
- If tests fail, resolve the issues before committing; document deviations in this plan.
- All work must occur directly on `main`; do not create topic branches.
