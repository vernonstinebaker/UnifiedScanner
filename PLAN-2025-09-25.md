# Implementation Plan (September 25, 2025)

This plan breaks down the architecture refactor into granular, trackable tasks. After each numbered step, the assignee must:

- ensure the project builds cleanly without warnings,
- run all relevant automated tests (including any newly added or modified tests) and verify they pass,
- review the diff for unintended changes,
- create a descriptive git commit,
- push the branch to the origin remote to preserve the incremental history.

If any step cannot be completed as written, document the variance in this file before proceeding.

## 1. Introduce Application Composition Layer
1.1 Create a new module or directory (e.g. `UnifiedScanner/AppEnvironment`) that defines protocols for shared services (`DeviceMutationBusProviding`, `LoggingServiceProviding`, `ClassificationServiceProviding`, etc.).
1.2 Implement concrete adapters that wrap the existing singleton-backed services but conform to the new protocols.
1.3 Update `UnifiedScannerApp` to instantiate an `AppEnvironment` struct/class that holds all service instances and inject it into the root view via environment objects or dependency containers.
1.4 Adjust unit tests that instantiate services directly so they can inject mock implementations through the environment.
1.5 Run tests, commit, and push.

## 2. Decompose SnapshotService
2.1 Extract persistence responsibilities into a dedicated `DevicePersistenceCoordinator` that encapsulates load/save and snapshot reload logic.
2.2 Move classification-trigger logic into a new collaborator (e.g. `DeviceClassificationCoordinator`) with an injectable scheduler/clock.
2.3 Introduce a lightweight `DeviceMutationPublisher` (protocol backed by `DeviceMutationBus`) that SnapshotService depends on instead of directly touching the singleton.
2.4 Refactor `SnapshotService` to delegate to these collaborators, ensuring actor isolation is maintained and public API behavior stays consistent.
2.5 Update affected tests (SnapshotService*, BroadcastExclusionPing, MutationStream, etc.) to use the new collaborators; add tests covering offline heartbeat with injected clock to remove reliance on `Task.sleep`.
2.6 Run tests, commit, and push.

## 3. Replace Global Singletons With Injected Dependencies
3.1 Update services (`HTTPFingerprintService`, `PortScanService`, `PingOrchestrator`, `DiscoveryCoordinator`, etc.) to accept dependencies via initializers rather than referencing static `shared` instances or global state.
3.2 Adjust UI entry points and the new `AppEnvironment` to pass concrete implementations explicitly.
3.3 Identify remaining global/static references (e.g. `LoggingService`, `DeviceMutationBus.shared`, `ClassificationService.setOUILookupProvider`) and provide adapter plumbing or configuration hooks.
3.4 Add/modify tests to verify that services operate correctly with mocked dependencies (focus on Ping/PortScan/Discovery coordinators).
3.5 Run tests, commit, and push.

## 4. Modularize Classification and Display Name Rules
4.1 Split `ClassificationService` into rule groups (fingerprint, hostname, service, port, fallback) represented as individual strategy types or data tables.
4.2 Create a registry or pipeline builder that assembles rule sets based on injected configuration, enabling simpler extension.
4.3 Extract Apple-specific display name and classification logic into dedicated modules that consume data from `AppleModelDatabase` (consider loading configuration from JSON/CSV instead of hard-coded arrays).
4.4 Ensure unit tests cover each strategy independently; add regression tests for previously brittle heuristics.
4.5 Run tests, commit, and push.

## 5. Consolidate UI Status Components and Interaction Logic
5.1 Refactor duplicated status/progress UI (currently in `ContentView`, `StatusSectionView`) into reusable components backed by view models sourced from the new environment.
5.2 Move interaction logic (open URL, copy to clipboard, run actions) out of `UnifiedDeviceDetail` into a testable view model, updating views to bind to published state/actions.
5.3 Update SwiftUI previews and existing UI tests (add new ones if missing) to reflect environment injection.
5.4 Run tests, commit, and push.

## 6. Final Integration Pass
6.1 Perform a holistic audit ensuring all modules use injected dependencies, no residual singletons remain in production code paths, and documentation reflects the new architecture.
6.2 Update README/PROJECT_OVERVIEW with a high-level summary of the new architecture and dependency injection approach.
6.3 Run the full test suite, perform a final code review, commit, and push.

---

**Testing & Version Control Expectations**
- At every step above, execute relevant test targets (`UnifiedScannerTests`, UI tests where applicable) and add or update tests alongside code changes.
- Every successful step must end with a git commit and a push to origin, using descriptive messages (e.g. "Refactor SnapshotService to use DevicePersistenceCoordinator").
- If tests fail, resolve the issues before committing; document deviations in this plan.
- All work must occur directly on `main`; do not create topic branches.
