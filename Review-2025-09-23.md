# UnifiedScanner Design / SRP Review (2025-09-23)

## Scope
Components reviewed:
- SnapshotService
- ClassificationService
- Device model (and associated enums/structs)
- DeviceDisplayNameResolver (and vendor sub-resolvers)

Baseline test run revealed broad regressions across classification, service derivation, device mutation ordering, and miscellaneous utilities. Some failures stem from intentional logic changes (e.g., MAC normalization, service raw type retention) not yet reconciled with legacy test expectations. Refactor recommendations below aim to clarify responsibilities, restore deterministic behavior, and isolate rule/config data from imperative code.

---
## SnapshotService
**Current Responsibilities**
- Device state store (in‑memory list + mutation emission)
- Device merge / upsert semantics (including service + port dedupe, fingerprints integration)
- Classification trigger logic (fingerprint-based diff + async classify)
- Name resolution trigger (autoName maintenance)
- Persistence (load/save via iCloud KVS + UserDefaults)
- Offline liveness heartbeat & sweep (time-based status decay)
- Mutation bus listener & re-broadcast (bridging DeviceMutationBus to per-subscriber AsyncStreams)
- Sanitization (filtering IPs; vendor/model derivation; OUI lookup fallback)
- Ordering/sorting of devices (IP aware comparator)

**SRP Assessment**: Overloaded. At least 6 distinct concerns reside here: (1) repository/storage, (2) mutation orchestration, (3) persistence, (4) classification coordination, (5) liveness/offline policy, (6) name derivation hook, (7) sanitization/normalization. Complexity increases test brittleness (ordering, timing). Current design also couples classification fingerprint logic to merge, complicating future alternative classification strategies.

**Key Pain Points**
- Hard-coded persistence key & always-on offline reset branch (`if true {}`) – reduces configurability & test clarity.
- Classification fingerprint string building inside SnapshotService duplicates feature knowledge; any rule expansion can inadvertently break diffing.
- Name resolution side-effect appended to upsert path mutates device (autoName) and injects a faux `hostname` change field to trigger UI refresh—semantic leakage.
- Asynchronous mutation processing via DeviceMutationBus + local AsyncStreams could lead to ordering nondeterminism vs tests expecting immediate sync emissions.
- Sanitization logic (IP filtering, vendor inference via fingerprints/OUI) embedded here; mixing of identity resolution and display heuristics.

**Recommendations**
1. Extract `DeviceRepository` protocol with minimal CRUD + stream; move persistence + in-memory list there. SnapshotService becomes `DeviceStoreCoordinator` that listens to external mutation sources.
2. Split `ClassificationCoordinator` (responsible for fingerprint diffing and invoking rule engine). Provide a lightweight `needsReclassification(previous: Device, updated: Device)` utility returning Bool.
3. Separate `Sanitizer` utility (pure functions) for IP filtering, vendor/model derivation. Return sanitized copy or nil; SnapshotService applies it.
4. Isolate `LivenessManager` (heartbeat task + offline sweep) configurable via intervals; decouple from persistence concerns.
5. Move auto name updating into a `DisplayNameManager` triggered via explicit call after classification OR into UI layer if acceptable. Avoid piggybacking a false `.hostname` change; introduce dedicated `.displayName` DeviceField instead of overloading.
6. Replace classification fingerprint string with a stable struct Hash (e.g., tuple of ordered arrays hashed) to reduce accidental drift & make unit testing of “should reclassify” independent.
7. Introduce dependency container initializer allowing tests to inject stub persistence, classifier, clock (for time). Clock injection enables deterministic recentlySeen/offline tests.

**Incremental Step Plan** (non-breaking sequence):
- Step 1: Introduce DeviceField `.displayName`; adjust tests expecting hostname change for autoName.
- Step 2: Extract pure `DeviceSanitizer` & `ClassificationTrigger.shouldReclassify(old:new:)` leaving existing call sites.
- Step 3: Factor out Liveness (heartbeat) behind protocol (start/stop, sweep())—makes offline tests explicit.
- Step 4: Move persistence to `DevicePersistenceRepository` with load/save + change notification; SnapshotService subscribes.
- Step 5: After tests green, optionally rename SnapshotService → DeviceStoreCoordinator.

---
## ClassificationService
**Current Role**
- Monolithic static function with internally grouped rule sets: fingerprintRules, vendorHostnameRules, serviceCombinationRules, portProfileRules, fallbackRules.
- Early short-circuit for authoritative fingerprint high-confidence results.
- OUI vendor inference actor for pluggable MAC prefix lookup.

**SRP Assessment**: Moderate cohesion but mixing (1) rule evaluation, (2) vendor inference IO, (3) candidate ranking strategy, (4) normalization/lowering. Fingerprint-specific Apple model vs generic rules are heavily interleaved. Commented-out Apple Mac heuristic (SSH + AirPlay) removed previously -> test regressions.

**Pain Points**
- Static function impedes dependency injection (harder to test rule subsets or introduce experimental rule sets).
- Candidate ranking logic (sort comparator) embedded; cannot tune tie-breaker weightings easily.
- Source tags inconsistent (`fingerprints:echo`, `fingerprint:model`, `vendor:printer`) – naming pattern should be canonical.
- Fallback removal of Mac heuristic leads to misclassification (HomePod vs tv) because earlier generic AirPlay rule claims tv before any speaker-specific fallback (when no authoritative fingerprint present).
- Apple family fingerprint logic dispersed (tv, homepod, macbook, etc.) but vendorHostnameRules also separately handles Apple TV; duplication risk.

**Recommendations**
1. Introduce `ClassificationEngine` instance with:
   - `Rule` protocol: evaluate(DeviceContext) -> [MatchResult]
   - Distinct rule sets arrays executed in phase order (FingerprintPhase, HighConfidencePhase, CombinationPhase, PortProfilePhase, FallbackPhase).
2. Move Apple-specific fingerprint family rules into dedicated `AppleFingerprintRule` consolidating logic; vendor/hostname Apple TV fallback in its own `AppleHostnameRule` (makes removal/priority explicit).
3. Reinstate Mac heuristic rule (SSH + AirPlay + vendor apple) at medium confidence after fingerprint phase but before generic AirPlay tv rule; ensure speaker vs tv differentiation: HomePod service pattern (AirPlayAudio only or RAOP without AirPlay?) separate rule returning `.speaker`.
4. Standardize source tag schema: `fp:model`, `fp:http`, `svc:airplay`, `host:appletv`, `vendor:apple`, `comb:ssh+airplay`, etc.
5. Externalize rule configuration for simple textual or JSON-based patterns (e.g., vendor keyword arrays) enabling enrichment without code changes.
6. Provide ranking strategy object implementing `select(candidates:)` to allow test isolation and future ML weighting.
7. Add `ClassificationContext` struct caching lowered host/vendor/service sets to avoid recomputation inside each rule.

**Minimal Near-Term Fix** (restore tests):
- Re-enable the commented Mac heuristic and introduce HomePod heuristic that sets `.speaker` when AirPlayAudio present without SSH.
- Adjust ordering so homepod speaker rule executes before generic tv rule.

---
## Device Model
**Current Role**
- Aggregates identity, network attributes, classification, services, ports, fingerprints, timeline, naming, online state.
- Provides derived computed properties (displayServices, recentlySeen, bestDisplayIP).
- Provides normalization (normalizeMAC) and ID derivation logic inside initializer.

**SRP Assessment**: Acceptable for a data aggregate but derived behaviors (displayServices) defer to external ServiceDeriver (good) while online/recentlySeen logic couples to real time (Date()). This harms deterministic tests (recentlySeen edges failing). Also MAC normalization change (now padded uppercase colonized) likely broke legacy test expecting raw uppercase no separators.

**Pain Points**
- `recentlySeen` uses global `Date()` making time-based tests flaky; tests failing edge cases.
- ID derivation logic potentially unstable when MAC formatting rules change (affects persistence). Need explicit migration or versioning note.
- `bestDisplayIP` preference ordering (primaryIP ?? heuristic) may not match tests expecting IPv6 precedence in link-local scenario (fail: IPv4 chosen over expected IPv6). Logic resides partly in IPHeuristics – mismatch of expectation.
- `DiscoverySource` and `MutationSource` enumeration duplication (two parallel concepts: discovery vs mutation). Could converge or document distinction.

**Recommendations**
1. Introduce injectable `Clock` (protocol) so `recentlySeen` becomes method `isRecentlySeen(now:)` or computed via static Clock.current overridable in tests.
2. Clarify MAC normalization contract; if tests want colon formatting, update tests or provide `originalMAC` vs `normalizedMAC` stored fields.
3. Add explicit `displayName` computed property consolidating user override vs autoName logic; remove duplication elsewhere.
4. Consider splitting ephemeral metrics (rttMillis, lastSeen, isOnlineOverride) into an auxiliary struct `DeviceRuntimeState` if persistence or sync layer diverges.
5. Provide stable ID precedence documentation and create test covering each branch (MAC > IP > hostname > UUID) for regression detection.

---
## DeviceDisplayNameResolver
**Current Role**
- Orchestrates multi-source naming: user override -> vendor-specific -> hostname -> classification -> vendor -> IP -> id with numeric noise suppression and brand casing normalization.
- Apple resolver integrates fingerprint model mapping via AppleModelDatabase and fallback heuristics (hostname family inference) plus classification fallback for Apple TV.

**SRP Assessment**: Largely cohesive; minor leakage of classification semantics (Apple TV fallback) and model extraction logic coupling with fingerprint vendor extraction that also appears in SnapshotService/classification.

**Pain Points**
- Duplicate extraction of fingerprint model vendor logic scattered (SnapshotService sanitize, ClassificationService, Resolver Apple section) – centralize `VendorModelExtractorService.extract` usage via a shared Device extension or unified context passed around.
- Score constants (90 fingerprint, 85 modelHint, 70 hostname model, 60 hostname, 80 classification mapping externally) are magic numbers; lack of centralized weighting configuration.
- Apple fallback granting generic "Apple TV" name based solely on form factor may mislabel non-Apple streaming devices if vendor inference failed but classification set tv (should check vendor contains apple before injecting brand-specific name).
- Lack of candidate source merging (if vendor resolver returns a value also derivable generically, sources not unified).

**Recommendations**
1. Introduce `NameCandidate` pipeline object similar to classification rules; unify scoring constants in `NameScoring` static struct.
2. Only apply Apple TV fallback if vendor explicitly Apple OR fingerprint indicates Apple context.
3. Provide optional injection of weighting config to allow A/B adjustments without code changes.
4. Expose a `resolveAll(for:) -> [ResolvedName]` for debugging / UI developer tools to show candidate stack, aiding tuning.
5. Consider passing precomputed `FingerprintExtraction` (vendor, model) so each layer doesn’t recompute.

---
## Cross-Cutting Concerns
**Logging**: Category usage is present (snapshot/classification) but inconsistent naming (`name_resolver` inline string vs LoggingService categories). Introduce enum case `.naming`.

**Source Tag Taxonomy**: Standardize to prefix namespaces:
- Fingerprints: `fp:model`, `fp:http`, `fp:txt:key`
- Services: `svc:ssh`, `svc:airplay`, `svc:raop`
- Ports: `port:80`
- Vendor: `vendor:apple`
- Host: `host:appletv`
- Rule combos: `rule:mac_combo`

**Testing Strategy Improvements**
- Provide fixtures for Device merging sequences; assert classification re-run count (with a mock classifier capturing invocations) to avoid brittle field comparison tests.
- Add tests for offline sweep with injected clock advancing.
- Add golden test enumerating classification candidates for a set of complex devices (Apple TV, HomePod, Mac, Router, IoT) to lock rule ordering.
- SnapshotService autoName test should assert `.displayName` rather than piggyback `.hostname` diff.

**Migration Risk Areas**
- Changing normalization or ID strategy without backfill could orphan persisted entries (duplicate devices). Provide migration step: on load, if two devices share normalized MAC after a rule change, merge them.
- Splitting SnapshotService may impact concurrency assumptions (MainActor). Keep new components either MainActor or sendable with explicit serialization.

---
## Immediate Bug/Regression Fix Priorities
1. Restore Apple Mac & HomePod non-fingerprint heuristics (before generic AirPlay tv) to fix classification + downstream tests.
2. Revisit ServiceDeriver vs tests expecting truncated rawType (decide canonical representation; update either code or tests systematically, not piecemeal).
3. Provide deterministic mutation ordering for DiscoveryCoordinator tests: ensure mDNS snapshot emission occurs before ping creation (may require buffering ping events until initial mDNS stage completes or explicit stage coordinator).
4. Reinstate or adapt MAC formatting expectation in tests (update tests if new canonical form is with colons; else add separate stored rawMAC and have normalizeMAC return original for ID only).
5. Introduce injectible clock to stabilize recentlySeen edge case tests.

---
## Proposed Refactor Phases
**Phase 0 (Stabilize)**: Minimal heuristic reinstatements + adjust failing tests to new canonical formatting decisions (or revert format change).
**Phase 1 (Extraction)**: DeviceSanitizer + ClassificationTrigger + introduce DeviceField.displayName.
**Phase 2 (Rule Engine)**: Modular ClassificationEngine with phased rule arrays; migrate existing rules verbatim.
**Phase 3 (Liveness & Persistence)**: LivenessManager + DevicePersistenceRepository; SnapshotService slimming.
**Phase 4 (Naming Pipeline)**: NameScoring config + resolveAll diagnostics; unify fingerprint extraction context.
**Phase 5 (Config Externalization)**: Move vendor keyword arrays and rule thresholds into JSON/plist for extension without code deploy.

Each phase should ship with targeted new tests (unit & integration) to lock in behavior before subsequent decompositions.

---
## Effort / Benefit Summary
| Recommendation | Effort | Risk | Benefit |
|----------------|-------|------|---------|
| Restore Mac/HomePod heuristics | Low | Low | Fixes multiple failing tests & user-visible accuracy |
| DeviceSanitizer extraction | Low | Low | Clarifies merge path; easier unit tests |
| ClassificationEngine modularization | Medium | Medium | Extensible rules, clearer priority & test coverage |
| LivenessManager extraction | Medium | Low | Deterministic offline behavior tests |
| NameScoring centralization | Low | Low | Simplifies tuning & experimentation |
| Inject Clock | Low | Low | Fix flaky time-based tests |
| Persistence repository | Medium | Medium | Simplifies SnapshotService & future multi-store support |
| Source tag taxonomy | Low | Low | Easier debugging & analytics |
| resolveAll naming diagnostics | Low | Low | Developer insight for tuning |

---
## Next Steps (Recommended Execution Order)
1. Implement Apple heuristics + add tests (fix red suite cluster).
2. Add Clock protocol and patch recentlySeen tests.
3. Introduce DeviceField.displayName & adjust autoName update signaling (update tests).
4. Extract Sanitizer + ClassificationTrigger logic (pure functions + tests).
5. Modularize classification rules into discrete rule types (no behavior change) + candidate ranking strategy injection.
6. Add naming diagnostics + scoring centralization.
7. Plan persistence / liveness extraction (optional if not urgent).

Let me know if you’d like me to proceed directly with Step 1 (Apple heuristics) or begin with any structural extraction first.
